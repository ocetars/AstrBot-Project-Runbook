基于之前制定的 **Dev (开发) -> Beta (灰度) -> Master (稳定)** 三层架构，版本号的管理不再是随意的数字游戏，而是**“用户预期管理”**的核心工具。

对于 `AstrBot` 这样活跃的中型项目，我推荐采用 **“火车发版模型 (Release Train)”** 结合 **语义化版本 (SemVer)**。

核心原则：**节奏 > 功能**。不要等功能做完再发版，而是**时间到了就发版**，没做完的功能搭下一班车。

---

### 一、 版本号定义与频次矩阵

严格遵守 `Major.Minor.Patch` (X.Y.Z) 规范。

| 版本类型 | 格式示例 | 定义标准 | 建议频次 | 触发条件 |
| :--- | :--- | :--- | :--- | :--- |
| **Patch (补丁)** | `1.2.1` -> `1.2.2` | **向后兼容的 Bug 修复**。<br>绝不包含新功能。 | **按需发布**<br>(最快当天，最慢一周) | 发现生产环境有严重 Bug (P0/P1 级)。 |
| **Minor (次版本)** | `1.2.0` -> `1.3.0` | **向后兼容的新功能**。<br>包含新特性、性能优化。 | **固定周期**<br>(建议 2-3 周) | 到了发版日，Dev 分支有新东西。 |
| **Major (主版本)** | `1.0.0` -> `2.0.0` | **不兼容的 API 变更**。<br>配置结构改变、插件接口重构。 | **极低频**<br>(建议 6-12 个月) | 架构重构，需要用户手动迁移数据/修改配置时。 |

---

### 二、 详细发版逻辑设计

#### 1. Minor 版本：定期发车的“高铁” (The Release Train)
这是项目的主心骨。不要因为某个功能没写完而推迟发版，这会导致堆积。

*   **周期设定：** 建议定为 **每 2 周的周三** (避开周五，防止周末加班修 Bug)。
*   **流程：**
    1.  **切断 (Cut-off):** 周三到了，不管 Dev 分支上的功能有多少，直接将 Dev 当前状态合并到 Beta。
    2.  **版本号预设:** 假设上个版本是 `1.2.0`，此时 Beta 分支打上 Tag `v1.3.0-rc.1` (Release Candidate)。
    3.  **灰度验证:** 通知核心群友更新到 Beta 分支。
    4.  **正式发布:** 观察 3-5 天（下周一），如果没有严重 Bug，Beta 合并入 Master，打 Tag `v1.3.0`。
*   **没赶上怎么办？** 如果某个大功能只写了一半，使用 `Feature Flag` (功能开关) 隐藏它，或者不合并进 Dev，等下一班车（两周后）。

#### 2. Patch 版本：紧急救火队 (Hotfix)
当 Master 分支出现严重 Bug（如无法启动、核心功能崩溃）时触发。

*   **严禁直接在 Master 修改。**
*   **正确流程 (Upstream First):**
    1.  在 `Dev` 分支修复 Bug。
    2.  确认修复后，使用 `git cherry-pick <commit-hash>` 将修复提交“摘取”到 `Beta` 分支。
    3.  验证无误后，`Beta` 紧急合并入 `Master`。
    4.  发布 `v1.2.1`。
*   **为什么这么麻烦？** 很多项目直接在 Master 修，结果忘了同步回 Dev，导致下个版本发布时，**同一个 Bug 又回来了**（Regression）。“Upstream First” 策略能永久根除这个问题。

#### 3. Major 版本：慎之又慎
只有在不得不破坏用户现有的 `config.json` 结构，或者重写了插件系统导致旧插件无法使用时，才升级 Major。

*   **策略：** 必须提供 `Migration Guide` (迁移指南) 甚至 `Migration Script` (迁移脚本)。
*   **预告：** 至少提前 1 个月在 Issue 置顶预告，给插件开发者适配时间。

---

### 三、 自动化版本号管理 (自动化建议)

不要人工去想下一个版本号是啥，很容易出错。建议在 CI/CD 中引入工具。

**推荐方案：beta 版本号自动累加**

在 `Beta` 分支上，每次代码变动自动构建 Docker 镜像或发版时，版本号逻辑如下：

*   **Dev 分支:** 不打 SemVer Tag，使用 `nightly-YYYYMMDD` 或 `dev-commit_hash`。
*   **Beta 分支:**
    *   当合并进来时，检查 `package.json`。
    *   如果是 `1.3.0`，自动追加后缀 -> `1.3.0-beta.1`。
    *   发现 Bug 修复了一次 -> `1.3.0-beta.2`。
    *   又修了一次 -> `1.3.0-beta.3`。
*   **Master 分支:**
    *   去掉后缀，定格为 `1.3.0`。

### 四、 给你的具体执行建议（Cheat Sheet）

针对 `AstrBot`，建议采用 **"双周迭代制"**：

1.  **单周（开发周）：** 作者疯狂推代码到 `dev`，处理 Issue。
2.  **双周的周一（灰度日）：** `dev` -> `beta`。发布 `v1.x.0-beta`。在群里喊一声。
3.  **双周的周四（发布日）：** 如果 `beta` 没炸，`beta` -> `master`。发布 `v1.x.0`。
4.  **周末：** 休息。

**如何处理 Issue 里的催更？**
一旦建立了这个节奏，当用户问“这个功能什么时候上？”时，你可以底气十足地回复：
> "该功能已合并入 dev，预计将在 **下周四 (12月xx日)** 的 v1.4.0 版本中正式发布。急用请切到 beta 分支。"

这既缓解了用户的焦虑，又保护了作者的开发节奏。


-------------------------------------------------------------------------------


## Beta 版本修复 bug 发版：
这是一个非常关键的操作细节。Beta 阶段发现 Bug 是**预期之内**的事（如果 Beta 没 Bug，那还要 Beta 干嘛？），处理不当最容易导致**“代码丢失”**或**“Bug 反复出现（Regression）”**。

核心原则只有一条：**“上游优先（Upstream First）”—— 永远在 Dev 修，然后搬运到 Beta。**

以下是标准操作手册：

### ❌ 绝对禁止的做法
1.  **直接在 Beta 分支上修改提交：**
    *   *后果：* 你的 Dev 分支还是坏的。下个版本你从 Dev 合并代码时，**这个 Bug 会复活**。
2.  **在 Beta 修完，反向 Merge 回 Dev：**
    *   *后果：* Beta 分支通常包含特定的构建配置或版本号，反向合并会污染 Dev 的提交历史，导致“毛线团”一样的 Git 线图。
3.  **为了修 Bug，把 Dev 分支再次全量 Merge 进 Beta：**
    *   *后果：* 假如你 Dev 上又有了 5 个新功能，你为了修 1 个 Bug 把这 5 个不稳定的新功能也带进 Beta 了，这会让 Beta 变得更不稳定。

---

### ✅ 正确做法：Cherry-Pick（摘取提交）模式

假设场景：
*   **Dev** 处于疯狂开发中。
*   **Beta** 是 `v1.3.0-rc.1`。
*   用户反馈 Beta 有个严重的“空指针异常”。

#### 步骤 1：在 Dev 分支复现并修复 (Fix Upstream)
首先确认 Dev 分支也有这个问题（通常肯定有）。
1.  切回 `dev` 分支。
2.  创建修复分支 `fix/npe-error`。
3.  提交修复代码。
4.  合并回 `dev` 分支。

> 此时：Dev 是好的，Beta 是坏的。

#### 步骤 2：使用 Cherry-Pick 同步到 Beta (Propagate Downstream)
我们需要把刚才那个**特定的修复 Commit**，“复制”一份到 Beta，但**不要**带上 Dev 的其他新功能。

假设刚才在 Dev 修复的 Commit ID 是 `a1b2c3d`。

```bash
# 1. 切换到 beta 分支
git checkout beta

# 2. 拉取最新代码（好习惯）
git pull origin beta

# 3. 摘取修复的那个 commit
git cherry-pick a1b2c3d

# 如果有冲突，解决冲突 -> git add . -> git cherry-pick --continue
```

#### 步骤 3：发布 Beta 新版本 (Bump Version)
修复进入 Beta 后，必须升级 Beta 的版本号，告诉测试用户“问题修好了”。

1.  修改版本号：从 `1.3.0-rc.1` -> `1.3.0-rc.2` (Release Candidate 2)。
2.  打 Tag 并推送。

```bash
git tag v1.3.0-rc.2
git push origin beta --tags
```

---

### 🎨 图解流程

```text
(Dev Branch) 🚧
   ... o ─── [A] ─── [B] ─── [Fix: a1b2c3d] ─── [C] ... (继续开发新功能)
              │                 │
              │                 │ (1. Cherry-Pick 复制这个修复)
              ▼                 ▼
(Beta Branch) 🧪
   ... ─── [Merge A] ──────── [Fix: a1b2c3d'] ─── (Ready for v1.3.0-rc.2)
           (v1.3.0-rc.1)        ▲
           (发现 Bug)            │
                                └─ 此时 Beta 只包含原来的代码 + 修复补丁
                                   而不包含 Dev 上的 commit [B] 和 [C]
```

---

### ❓ 特殊情况处理 QA

#### 情况 A：如果不修复这个 Bug，整个 Beta 版本没法用怎么办？
**场景：** 这个 Bug 太严重了，修起来要好几天，或者根本不知道怎么修，但 Beta 发布日又要到了。
**解法：Revert（回滚）。**
1.  在 `dev` 分支找到引入该 Bug 的那个 Feature Commit。
2.  `git revert <bad-commit-id>`（在 Dev 上先回滚，保证 Dev 变绿）。
3.  将这个 `Revert Commit` 同样 **Cherry-pick** 到 `beta` 分支。
4.  等下个版本修好了再重新加回来。

#### 情况 B：Cherry-pick 遇到剧烈冲突怎么办？
**场景：** 修复的那个文件在 Dev 上已经被改的面目全非了，Cherry-pick 过来全是冲突。
**解法：手动移植（Manual Backport）。**
不要硬解冲突。直接在 `beta` 分支上切一个 `hotfix-beta` 分支，**人工手写**同样的修复逻辑，然后合并进 `beta`。
*   **注意：** 这种情况要极力避免，说明 Dev 和 Beta 的差异过大了（通常是因为 Beta 拖了太久没发版）。

#### 情况 C：GitHub 界面上能不能操作？
可以。
如果你们不想用命令行，很多 Bot（如 `kodiakhq` 或 GitHub Actions）支持在 PR 的评论区输入指令：
`/cherry-pick beta`
机器人会自动把当前合并的 PR 复制一份提交到 beta 分支。
*如果没有配置机器人，建议还是手动 CLI 操作，最稳妥。*

### 总结
在 Beta 阶段修 Bug 的口诀：
**“Dev 修，Pick 走，版本升，继续测。”**